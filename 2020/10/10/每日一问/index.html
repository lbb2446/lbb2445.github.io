<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] 变量和类型JavaScript规定了几种类型 基本数据类型：Null、Undefined、Number，String，Boolean。 复杂数据类型：Object，Array  JavaScript对象的底层数据结构是什么  Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol  使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2020/10/10/每日一问/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 变量和类型JavaScript规定了几种类型 基本数据类型：Null、Undefined、Number，String，Boolean。 复杂数据类型：Object，Array  JavaScript对象的底层数据结构是什么  Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol  使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://segmentfault.com/img/bVCuzt?w=579&h=182">
<meta property="og:updated_time" content="2020-10-10T05:21:37.320Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="[TOC] 变量和类型JavaScript规定了几种类型 基本数据类型：Null、Undefined、Number，String，Boolean。 复杂数据类型：Object，Array  JavaScript对象的底层数据结构是什么  Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol  使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象">
<meta name="twitter:image" content="https://segmentfault.com/img/bVCuzt?w=579&h=182">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-每日一问" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/每日一问/" class="article-date">
  <time datetime="2020-10-10T05:21:37.320Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h1><h2 id="JavaScript规定了几种类型"><a href="#JavaScript规定了几种类型" class="headerlink" title="JavaScript规定了几种类型"></a>JavaScript规定了几种类型</h2><blockquote>
<p>基本数据类型：Null、Undefined、Number，String，Boolean。</p>
<p>复杂数据类型：Object，Array</p>
</blockquote>
<h2 id="JavaScript对象的底层数据结构是什么"><a href="#JavaScript对象的底层数据结构是什么" class="headerlink" title="JavaScript对象的底层数据结构是什么"></a>JavaScript对象的底层数据结构是什么</h2><blockquote>
</blockquote>
<h2 id="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><a href="#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol" class="headerlink" title="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h2><blockquote>
<p> 使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> generateName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> postfix = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">descString</span>)</span>&#123;</span><br><span class="line">         postfix++;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">'@@'</span> + descString + <span class="string">'_'</span> + postfix</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SymbolPolyfill) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">         toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.__Name__;</span><br><span class="line">         &#125;,</span><br><span class="line">         valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">     <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">         <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">             value: descString,</span><br><span class="line">             writable: <span class="literal">false</span>,</span><br><span class="line">             enumerable: <span class="literal">false</span>,</span><br><span class="line">             configurable: <span class="literal">false</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'__Name__'</span>: &#123;</span><br><span class="line">             value: generateName(descString),</span><br><span class="line">             writable: <span class="literal">false</span>,</span><br><span class="line">             enumerable: <span class="literal">false</span>,</span><br><span class="line">             configurable: <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> symbol;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> forMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class="line">     <span class="string">'for'</span>: &#123;</span><br><span class="line">         value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">             <span class="keyword">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class="line">         &#125;,</span><br><span class="line">         writable: <span class="literal">true</span>,</span><br><span class="line">         enumerable: <span class="literal">false</span>,</span><br><span class="line">         configurable: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">'keyFor'</span>: &#123;</span><br><span class="line">         value: <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> forMap) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (forMap[key] === symbol) <span class="keyword">return</span> key;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         writable: <span class="literal">true</span>,</span><br><span class="line">         enumerable: <span class="literal">false</span>,</span><br><span class="line">         configurable: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> root.SymbolPolyfill = SymbolPolyfill;</span><br><span class="line"> &#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript中的变量在内存中的具体存储形式"><a href="#JavaScript中的变量在内存中的具体存储形式" class="headerlink" title="JavaScript中的变量在内存中的具体存储形式"></a>JavaScript中的变量在内存中的具体存储形式</h2><blockquote>
<p>值类型和引用类型。存在堆和栈中。 如图所示:<img src="https://segmentfault.com/img/bVCuzt?w=579&h=182" alt="å¾çæè¿°"></p>
<h3 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈:"></a>堆&amp;栈:</h3><p>栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。<br>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p>
<p>栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。<br>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序</p>
</blockquote>
<h2 id="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"><a href="#基本类型对应的内置对象，以及他们之间的装箱拆箱操作" class="headerlink" title="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"></a>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h2><p>装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。<br>string（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.</p>
<p>拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。</p>
<h2 id="理解值类型和引用类型"><a href="#理解值类型和引用类型" class="headerlink" title="理解值类型和引用类型"></a>理解值类型和引用类型</h2><blockquote>
<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>
<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。</p>
</blockquote>
<h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><blockquote>
<p>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
</blockquote>
<h2 id="至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"><a href="#至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型" class="headerlink" title="至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"></a>至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h2><blockquote>
<p><strong>typeof</strong> </p>
<ul>
<li><p>对于基本类型，除 null 以外，均可以返回正确的结果。</p>
</li>
<li><p>对于引用类型，除 function 以外，一律返回 object 类型。</p>
</li>
<li><p>对于 null ，返回 object 类型。</p>
</li>
<li><p>对于 function 返回  function 类型。</p>
</li>
</ul>
</blockquote>
<blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h3><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型</p>
</blockquote>
<blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h3><p> null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</blockquote>
<h2 id="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"><a href="#可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用" class="headerlink" title="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"></a>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h2><blockquote>
<p>隐式转换中主要涉及到三种转换：</p>
<p>1、将值转为原始值，ToPrimitive()。</p>
<p>2、将值转为数字，ToNumber()。</p>
<p>3、将值转为字符串，ToString()</p>
<p> 如何避免：使用ts。巧妙应用：尽量不要用</p>
</blockquote>
<h2 id="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"><a href="#出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法" class="headerlink" title="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"></a>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h2><blockquote>
<p>发生场景： 0.1 + 0.2 === 0.30000000000000004</p>
<p>细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储</p>
<p>(0.1).toString(‘2’) // “0.0001100110011001100110011001100110011001100110011001101” </p>
<p>(0.2).toString(‘2’) // “0.001100110011001100110011001100110011001100110011001101”</p>
<p> (0.1+0.2).toString(‘2’) // “0.0100110011001100110011001100110011001100110011001101” </p>
<p>(0.3).toString(‘2’) // “0.010011001100110011001100110011001100110011001100110011”</p>
</blockquote>
<h4 id="ES6解决方案"><a href="#ES6解决方案" class="headerlink" title="ES6解决方案"></a>ES6解决方案</h4><p>ES6在Number对象上新增了一个极小的常量——Number.EPSILON</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// &quot;0.00000000000000022204&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。</p>
<p>误差检查函数（出自《ES6标准入门》-阮一峰）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withinErrorMargin (left, right) &#123;</span><br><span class="line">    return Math.abs(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(0.1+0.2, 0.3)</span><br></pre></td></tr></table></figure>

<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="理解原型设计模式以及JavaScript中的原型规则"><a href="#理解原型设计模式以及JavaScript中的原型规则" class="headerlink" title="理解原型设计模式以及JavaScript中的原型规则"></a>理解原型设计模式以及JavaScript中的原型规则</h2><h2 id="instanceof的底层实现原理，手动实现一个instanceof"><a href="#instanceof的底层实现原理，手动实现一个instanceof" class="headerlink" title="instanceof的底层实现原理，手动实现一个instanceof"></a>instanceof的底层实现原理，手动实现一个instanceof</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function my_instanceof(obj, constructor) &#123;</span><br><span class="line">  let constuctProto = constructor.prototype</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (obj.__protp__ === null) &#123;</span><br><span class="line">      // 遍历完对象的原型链</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj.__proto__ === constuctProto) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    obj = obj.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.实现继承的几种方式以及他们的优缺点</p>
<blockquote>
<ol>
<li>prototype</li>
<li>extend</li>
<li>create</li>
</ol>
</blockquote>
<p>5.至少说出一种开源项目(如Node)中应用原型继承的案例</p>
<p>6.可以描述new一个对象的详细过程，手动实现一个new操作符</p>
<blockquote>
<p>首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说</p>
<p>然后吧argumentsy映射到新建的对象上（引用地址）</p>
<p>把原型链映射到新建的对象上</p>
</blockquote>
<p>7.理解es6 class构造以及继承的底层实现原理</p>
<blockquote>
<p>应该就是语法糖，对于prototype的优化把</p>
</blockquote>
<p>作用域和闭包<br>1.理解词法作用域和动态作用域</p>
<blockquote>
<p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
</blockquote>
<p>2.理解JavaScript的作用域和作用域链</p>
<blockquote>
<h3 id="全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象"><a href="#全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象" class="headerlink" title="全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象"></a>全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象</h3><h3 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h3><h2 id="作用域链-Scope-Chain-：所有的变量都会向上寻找表示"><a href="#作用域链-Scope-Chain-：所有的变量都会向上寻找表示" class="headerlink" title="作用域链(Scope Chain)：所有的变量都会向上寻找表示"></a>作用域链(Scope Chain)：所有的变量都会向上寻找表示</h2><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>
</blockquote>
<p>3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</p>
<blockquote>
<p>无法叙述</p>
</blockquote>
<p>4.this的原理以及几种不同使用场景的取值</p>
<blockquote>
<p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>
</blockquote>
<h4 id="情况一：全局-amp-调用普通函数"><a href="#情况一：全局-amp-调用普通函数" class="headerlink" title="情况一：全局 &amp; 调用普通函数"></a>情况一：全局 &amp; 调用普通函数</h4><p>在全局环境中，this 永远指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this === window);     //true</span><br></pre></td></tr></table></figure>

<p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this);     //Window</span><br><span class="line">    console.log(this.x);   //10</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h4 id="情况二：构造函数"><a href="#情况二：构造函数" class="headerlink" title="情况二：构造函数"></a>情况二：构造函数</h4><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">    console.log(this);    //Foo &#123;x:10&#125;</span><br><span class="line">&#125;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">console.log(foo.x);      //10</span><br></pre></td></tr></table></figure>

<p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p>
<p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">    console.log(this);    //Window</span><br><span class="line">&#125;</span><br><span class="line">var foo = Foo();</span><br><span class="line">console.log(foo.x);      //undefined</span><br></pre></td></tr></table></figure>

<h4 id="情况三：对象方法"><a href="#情况三：对象方法" class="headerlink" title="情况三：对象方法"></a>情况三：对象方法</h4><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        console.log(this);        //Object</span><br><span class="line">        console.log(this.x);      //10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p><strong>注意：若是在对象方法中定义函数，那么情况就不同了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        function f()&#123;</span><br><span class="line">            console.log(this);      //Window</span><br><span class="line">            console.log(this.x);    //undefined</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p>
<p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        function f()&#123;</span><br><span class="line">            console.log(self);      //&#123;x: 10&#125;</span><br><span class="line">            console.log(self.x);    //10</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>如果 foo 函数不作为对象方法被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        console.log(this);       //Window</span><br><span class="line">        console.log(this.x);     //undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var fn = obj.foo;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>
<h4 id="情况四：构造函数-prototype-属性"><a href="#情况四：构造函数-prototype-属性" class="headerlink" title="情况四：构造函数 prototype 属性"></a>情况四：构造函数 prototype 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getX = function () &#123;</span><br><span class="line">    console.log(this);        //Foo &#123;x: 10, getX: function&#125;</span><br><span class="line">    console.log(this.x);      //10</span><br><span class="line">&#125;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.getX();</span><br></pre></td></tr></table></figure>

<p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p>
<h4 id="情况五：函数用-call、apply或者-bind-调用。"><a href="#情况五：函数用-call、apply或者-bind-调用。" class="headerlink" title="情况五：函数用 call、apply或者 bind 调用。"></a>情况五：函数用 call、apply或者 bind 调用。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this);     //&#123;x: 10&#125;</span><br><span class="line">    console.log(this.x);   //10</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj);</span><br><span class="line">foo.apply(obj);</span><br><span class="line">foo.bind(obj)();</span><br></pre></td></tr></table></figure>

<p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p>
<h4 id="情况六：DOM-event-this"><a href="#情况六：DOM-event-this" class="headerlink" title="情况六：DOM event this"></a>情况六：DOM event this</h4><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Listener()&#123;   </span><br><span class="line">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this</span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = function (event) &#123;</span><br><span class="line">    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">var listener = new Listener();</span><br><span class="line">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>

<p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">        console.log(this);         //Window</span><br><span class="line">        console.log(this.x);       //undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function foo(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125; </span><br><span class="line">foo(obj.fn);</span><br></pre></td></tr></table></figure>

<p>你也可以用通过 bind 切换上下文:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function  Listener()&#123;</span><br><span class="line">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      </span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = function (event) &#123;</span><br><span class="line">    console.log(this);    //Listener &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var listener = new Listener();</span><br><span class="line">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>

<p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p>
<h4 id="情况七：箭头函数中的-this"><a href="#情况七：箭头函数中的-this" class="headerlink" title="情况七：箭头函数中的 this"></a>情况七：箭头函数中的 this</h4><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                return () =&gt; &#123;</span><br><span class="line">                    console.log(this);      //Object &#123;x: 10&#125;</span><br><span class="line">                    console.log(this.x);    //10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn()()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p>
<p>如果使用箭头函数，以前的这种 hack 写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var self = this;</span><br></pre></td></tr></table></figure>

<p>就不再需要了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                return () =&gt; &#123;</span><br><span class="line">                    console.log(this);    // Object &#123;x: 10&#125;</span><br><span class="line">                    console.log(this.x);  //10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn.bind(&#123;x: 14&#125;)()()();</span><br><span class="line">        fn.call(&#123;x: 14&#125;)()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>
<h2 id="5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"><a href="#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用" class="headerlink" title="5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"></a>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</h2><p>JavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。<br>JavaScript闭包的本质是内存泄漏，指定内存不释放。 </p>
<p>应用：私有变量</p>
<p>##6.理解堆栈溢出和内存泄漏的原理，如何防止</p>
<p>溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包</p>
<h1 id="7-如何处理循环的异步操作"><a href="#7-如何处理循环的异步操作" class="headerlink" title="7.如何处理循环的异步操作"></a>7.如何处理循环的异步操作</h1><p>promise.all</p>
<p>#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</p>
<p>amd cmd umd    -》sea require npm</p>
<p>(function(a){</p>
<p>returm {</p>
<p>a:1</p>
<p>}<br>})(1)</p>
<p>#执行机制</p>
<p>##1.为何try里面放return，finally还会执行，理解其内部机制</p>
<p>类似promise？</p>
<p>##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</p>
<p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。</p>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop" target="_blank" rel="noopener">事件循环</a>期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>
<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##3.宏任务和微任务分别有哪些</p>
<p>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</p>
<p>分清楚 promise await settimeout的执行顺序</p>
<p>5.使用Promise实现串行</p>
<p>找一个第三方的缓存，把状态缓存住就行了</p>
<p>6.Node与浏览器EventLoop的差异</p>
<p>7.如何在保证页面运行流畅的情况下处理海量数据</p>
<p>不加载海量dom</p>
<p>语法和API<br>1.理解ECMAScript和JavaScript的关系</p>
<p>ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)</p>
<p>2.熟练运用es5、es6提供的语法规范，</p>
<p>3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</p>
<p>4.熟练应用map、reduce、filter 等高阶函数解决问题</p>
<p>5.setInterval需要注意的点，使用settimeout实现setInterval</p>
<p>6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</p>
<p>7.JavaScript异常处理的方式，统一的异常处理方案</p>
<p>HTML和CSS</p>
<p>HTML<br>1.从规范的角度理解HTML，从分类和语义的角度使用标签</p>
<p>早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化</p>
<p>2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式</p>
<p>3.元信息类标签(head、title、meta)的使用目的和配置方法</p>
<p>4.HTML5离线缓存原理</p>
<p>5.可以使用Canvas API、SVG等绘制高性能的动画</p>
<p>CSS<br>1.CSS盒模型，在不同浏览器的差异</p>
<p>2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则</p>
<p>3.CSS伪类和伪元素有哪些，它们的区别和实际应用</p>
<p>4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</p>
<p>5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点</p>
<p>6.BFC实现原理，可以解决的问题，如何创建BFC</p>
<p>7.可使用CSS函数复用代码，实现特殊效果</p>
<p>8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种</p>
<p>9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染</p>
<p>10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等</p>
<p>11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况</p>
<p>12.掌握一套完整的响应式布局方案</p>
<p>手写<br>1.手写图片瀑布流效果</p>
<p>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）</p>
<p>3.使用纯CSS实现曲线运动（贝塞尔曲线）</p>
<p>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p>
<p>计算机基础<br>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。<br>编译原理<br>1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</p>
<p>2.正则表达式的匹配原理和性能优化</p>
<p>3.如何将JavaScript代码解析成抽象语法树(AST)</p>
<p>4.base64的编码原理</p>
<p>5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换</p>
<p>网络协议<br>1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用</p>
<p>2.三次握手和四次挥手详细原理，为什么要使用这种机制</p>
<p>3.有哪些协议是可靠，TCP有哪些手段保证可靠交付</p>
<p>4.DNS的作用、DNS解析的详细过程，DNS优化原理</p>
<p>5.CDN的作用和原理</p>
<p>6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</p>
<p>7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题</p>
<p>8.HTTP1.1、HTTP2.0带来的改变</p>
<p>9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求</p>
<p>10.理解WebSocket协议的底层原理、与HTTP的区别</p>
<p>设计模式<br>1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</p>
<p>2.发布订阅模式和观察者模式的异同以及实际应用</p>
<p>3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</p>
<p>数据结构和算法<br>据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！</p>
<p>JavaScript编码能力<br>1.多种方式实现数组去重、扁平化、对比优缺点</p>
<p>2.多种方式实现深拷贝、对比优缺点</p>
<p>3.手写函数柯里化工具函数、并理解其应用场景和优势</p>
<p>4.手写防抖和节流工具函数、并理解其内部原理和应用场景</p>
<p>5.实现一个sleep函数</p>
<p>手动实现前端轮子<br>1.手动实现call、apply、bind</p>
<p>2.手动实现符合Promise/A+规范的Promise、手动实现async await</p>
<p>3.手写一个EventEmitter实现事件发布、订阅</p>
<p>4.可以说出两种实现双向绑定的方案、可以手动实现</p>
<p>5.手写JSON.stringify、JSON.parse</p>
<p>6.手写一个模版引擎，并能解释其中原理</p>
<p>7.手写懒加载、下拉刷新、上拉加载、预加载等效果</p>
<p>数据结构<br>1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</p>
<p>2.理解数组、字符串的存储原理，并熟练应用他们解决问题</p>
<p>3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</p>
<p>4.了解图、堆的基本结构和使用场景</p>
<p>算法<br>1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</p>
<p>2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度</p>
<p>3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</p>
<p>4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</p>
<p>5.前端处理海量数据的算法方案</p>
<p>运行环境<br>我们需要理清语言和环境的关系：<br>ECMAScript描述了JavaScript语言的语法和基本对象规范</p>
<p>浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口</p>
<p>Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API</p>
<p>浏览器API<br>1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性</p>
<p>2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性</p>
<p>3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)</p>
<p>4.浏览器海量数据存储、操作性能优化</p>
<p>5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理</p>
<p>6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库</p>
<p>7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型</p>
<p>8.浏览器提供的几种存储机制、优缺点、开发中正确的选择</p>
<p>9.浏览器跨标签通信</p>
<p>浏览器原理<br>1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分</p>
<p>2.请求数据到请求结束与服务器进行了几次交互</p>
<p>3.可详细描述浏览器从输入URL到页面展现的详细过程</p>
<p>4.浏览器解析HTML代码的原理，以及构建DOM树的流程</p>
<p>5.浏览器如何解析CSS规则，并将其应用到DOM树上</p>
<p>6.浏览器如何将解析好的带有样式的DOM树进行绘制</p>
<p>7.浏览器的运行机制，如何配置资源异步同步加载</p>
<p>8.浏览器回流与重绘的底层原理，引发原因，如何有效避免</p>
<p>9.浏览器的垃圾回收机制，如何避免内存泄漏</p>
<p>10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案</p>
<p>Node<br>1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等</p>
<p>2.掌握一种Node开发框架，如Express，Express和Koa的区别</p>
<p>3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理</p>
<p>4.Node的底层运行原理、和浏览器的异同</p>
<p>5.Node事件驱动、非阻塞机制的实现原理</p>
<p>框架和类库<br>轮子层出不穷，从原理上理解才是正道<br>TypeScript<br>1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现</p>
<p>2.理解使用TypeScript的好处，掌握TypeScript基础语法</p>
<p>3.TypeScript的规则检测原理</p>
<p>4.可以在React、Vue等框架中使用TypeScript进行开发</p>
<p>React<br>1.React和vue 选型和优缺点、核心架构的区别</p>
<p>2.React中setState的执行机制，如何有效的管理状态</p>
<p>3.React的事件底层实现机制</p>
<p>4.React的虚拟DOM和Diff算法的内部实现</p>
<p>5.React的Fiber工作原理，解决了什么问题</p>
<p>6.React Router和Vue Router的底层实现原理、动态加载实现原理</p>
<p>7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题</p>
<p>8.基于React的特性和原理，可以手动实现一个简单的React</p>
<p>Vue<br>1.熟练使用Vue的API、生命周期、钩子函数</p>
<p>2.MVVM框架设计理念</p>
<p>3.Vue双向绑定实现原理、Diff算法的内部实现</p>
<p>4.Vue的事件机制</p>
<p>5.从template转换成真实DOM的实现机制</p>
<p>多端开发<br>1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案</p>
<p>2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用</p>
<p>3.移动端页面适配解决方案、不同机型适配方案</p>
<p>4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配</p>
<p>5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理</p>
<p>6.掌握一种小程序开发框架或原生小程序开发</p>
<p>7.理解多端框架的内部实现原理，至少了解一个多端框架的使用</p>
<p>数据流管理<br>1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同</p>
<p>2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理</p>
<p>3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势</p>
<p>4.熟练使用Vuex管理数据流，并理解其实现原理</p>
<p>5.以上数据流方案的异同和优缺点，不情况下的技术选型</p>
<p>实用库<br>1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现</p>
<p>2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表</p>
<p>3.掌握一种GIS开发框架，如百度地图API</p>
<p>4.掌握一种可视化开发框架，如Three.js、D3</p>
<p>5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理</p>
<p>开发和调试<br>1.熟练使用各浏览器提供的调试工具</p>
<p>2.熟练使用一种代理工具实现请求代理、抓包，如charls</p>
<p>3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案</p>
<p>4.了解Vue、React等框架调试工具的使用</p>
<p>前端工程<br>前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度<br>项目构建<br>1.理解npm、yarn依赖包管理的原理，两者的区别</p>
<p>2.可以使用npm运行自定义脚本</p>
<p>3.理解Babel、ESLint、webpack等工具在项目中承担的作用</p>
<p>4.ESLint规则检测原理，常用的ESLint配置</p>
<p>5.Babel的核心原理，可以自己编写一个Babel插件</p>
<p>6.可以配置一种前端代码兼容方案，如Polyfill</p>
<p>7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用</p>
<p>8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins</p>
<p>nginx<br>1.正向代理与反向代理的特点和实例</p>
<p>2.可手动搭建一个简单的nginx服务器、</p>
<p>3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法</p>
<p>4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理</p>
<p>开发提速<br>1.熟练掌握一种接口管理、接口mock工具的使用，如yapi</p>
<p>2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题</p>
<p>3.理解TDD与BDD模式，至少会使用一种前端单元测试框架</p>
<p>版本控制<br>1.理解Git的核心原理、工作流程、和SVN的区别</p>
<p>2.熟练使用常规的Git命令、git rebase、git stash等进阶命令</p>
<p>3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题</p>
<p>持续集成<br>1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins</p>
<p>2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）</p>
<p>项目和业务</p>
<p>后端技能<br>1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言</p>
<p>2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库</p>
<p>性能优化<br>1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案</p>
<p>2.了解常见的Web、App性能优化方案</p>
<p>3.SEO排名规则、SEO优化方案、前后端分离的SEO</p>
<p>4.SSR实现方案、优缺点、及其性能优化</p>
<p>5.Webpack的性能优化方案</p>
<p>6.Canvas性能优化方案</p>
<p>7.React、Vue等框架使用性能优化方案</p>
<p>前端安全<br>1.XSS攻击的原理、分类、具体案例，前端如何防御</p>
<p>2.CSRF攻击的原理、具体案例，前端如何防御</p>
<p>3.HTTP劫持、页面劫持的原理、防御措施</p>
<p>业务相关<br>1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题</p>
<p>2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题</p>
<p>3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性</p>
<p>学习提升</p>
<p>vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：</p>
<p>这十几年我一共做了三件事：</p>
<p>1、不以赚钱为目的选择学习的内容；</p>
<p>2、以自己是否能造出轮子来衡量学习的效果；</p>
<p>3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。</p>
<p>上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。</p>
<p>关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多</p>
<p>1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏</p>
<p>2.定期的将知识进行总结，不断完善自己的知识体系</p>
<p>3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用</p>
<p>4.坚持输出自己的代码，不要盲目的扎进公司业</p>
<p>技术之外</p>
<p>这部分可能比上面九条加起来重要！</p>
<p>1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等</p>
<p>2.了解互联网行业术语：B2B、B2C、C2C、O2O等</p>
<p>3.掌握互联网行业沟通、问答、学习的</p>
<p>4.有一定的”PPT”能力</p>
<p>5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识</p>
<p>6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系<br>.如何理解 JS 中的this关键字？</p>
<ol>
<li>由于 this 关键字很混乱，如何解决这个问题<br>3.什么是闭包<br>4.解释一下变量的提升</li>
<li>JavaScript如何处理同步和异步情况</li>
<li>如何理解事件委托</li>
<li>如何理解高阶函数。</li>
<li>如何区分声明函数和表达式函数</li>
<li>解释一下严格模式(strict mode)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/每日一问/" data-id="ckg39g70y0005l8vpl4jt6780" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/10/10/设计模式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/10/每日一问/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/设计模式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/form表单规范/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/10/less/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>