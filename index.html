<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-每日一问" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/每日一问/" class="article-date">
  <time datetime="2020-10-10T05:21:37.320Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h1><h2 id="JavaScript规定了几种类型"><a href="#JavaScript规定了几种类型" class="headerlink" title="JavaScript规定了几种类型"></a>JavaScript规定了几种类型</h2><blockquote>
<p>基本数据类型：Null、Undefined、Number，String，Boolean。</p>
<p>复杂数据类型：Object，Array</p>
</blockquote>
<h2 id="JavaScript对象的底层数据结构是什么"><a href="#JavaScript对象的底层数据结构是什么" class="headerlink" title="JavaScript对象的底层数据结构是什么"></a>JavaScript对象的底层数据结构是什么</h2><blockquote>
</blockquote>
<h2 id="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><a href="#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol" class="headerlink" title="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h2><blockquote>
<p> 使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> generateName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> postfix = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">descString</span>)</span>&#123;</span><br><span class="line">         postfix++;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">'@@'</span> + descString + <span class="string">'_'</span> + postfix</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SymbolPolyfill) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">         toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.__Name__;</span><br><span class="line">         &#125;,</span><br><span class="line">         valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">     <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">         <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">             value: descString,</span><br><span class="line">             writable: <span class="literal">false</span>,</span><br><span class="line">             enumerable: <span class="literal">false</span>,</span><br><span class="line">             configurable: <span class="literal">false</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'__Name__'</span>: &#123;</span><br><span class="line">             value: generateName(descString),</span><br><span class="line">             writable: <span class="literal">false</span>,</span><br><span class="line">             enumerable: <span class="literal">false</span>,</span><br><span class="line">             configurable: <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> symbol;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> forMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class="line">     <span class="string">'for'</span>: &#123;</span><br><span class="line">         value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">             <span class="keyword">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class="line">         &#125;,</span><br><span class="line">         writable: <span class="literal">true</span>,</span><br><span class="line">         enumerable: <span class="literal">false</span>,</span><br><span class="line">         configurable: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">'keyFor'</span>: &#123;</span><br><span class="line">         value: <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> forMap) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (forMap[key] === symbol) <span class="keyword">return</span> key;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         writable: <span class="literal">true</span>,</span><br><span class="line">         enumerable: <span class="literal">false</span>,</span><br><span class="line">         configurable: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> root.SymbolPolyfill = SymbolPolyfill;</span><br><span class="line"> &#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript中的变量在内存中的具体存储形式"><a href="#JavaScript中的变量在内存中的具体存储形式" class="headerlink" title="JavaScript中的变量在内存中的具体存储形式"></a>JavaScript中的变量在内存中的具体存储形式</h2><blockquote>
<p>值类型和引用类型。存在堆和栈中。 如图所示:<img src="https://segmentfault.com/img/bVCuzt?w=579&h=182" alt="å¾çæè¿°"></p>
<h3 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈:"></a>堆&amp;栈:</h3><p>栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。<br>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p>
<p>栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。<br>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序</p>
</blockquote>
<h2 id="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"><a href="#基本类型对应的内置对象，以及他们之间的装箱拆箱操作" class="headerlink" title="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"></a>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h2><p>装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。<br>string（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.</p>
<p>拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。</p>
<h2 id="理解值类型和引用类型"><a href="#理解值类型和引用类型" class="headerlink" title="理解值类型和引用类型"></a>理解值类型和引用类型</h2><blockquote>
<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>
<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。</p>
</blockquote>
<h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><blockquote>
<p>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
</blockquote>
<h2 id="至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"><a href="#至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型" class="headerlink" title="至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"></a>至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h2><blockquote>
<p><strong>typeof</strong> </p>
<ul>
<li><p>对于基本类型，除 null 以外，均可以返回正确的结果。</p>
</li>
<li><p>对于引用类型，除 function 以外，一律返回 object 类型。</p>
</li>
<li><p>对于 null ，返回 object 类型。</p>
</li>
<li><p>对于 function 返回  function 类型。</p>
</li>
</ul>
</blockquote>
<blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h3><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型</p>
</blockquote>
<blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h3><p> null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</blockquote>
<h2 id="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"><a href="#可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用" class="headerlink" title="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"></a>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h2><blockquote>
<p>隐式转换中主要涉及到三种转换：</p>
<p>1、将值转为原始值，ToPrimitive()。</p>
<p>2、将值转为数字，ToNumber()。</p>
<p>3、将值转为字符串，ToString()</p>
<p> 如何避免：使用ts。巧妙应用：尽量不要用</p>
</blockquote>
<h2 id="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"><a href="#出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法" class="headerlink" title="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"></a>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h2><blockquote>
<p>发生场景： 0.1 + 0.2 === 0.30000000000000004</p>
<p>细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储</p>
<p>(0.1).toString(‘2’) // “0.0001100110011001100110011001100110011001100110011001101” </p>
<p>(0.2).toString(‘2’) // “0.001100110011001100110011001100110011001100110011001101”</p>
<p> (0.1+0.2).toString(‘2’) // “0.0100110011001100110011001100110011001100110011001101” </p>
<p>(0.3).toString(‘2’) // “0.010011001100110011001100110011001100110011001100110011”</p>
</blockquote>
<h4 id="ES6解决方案"><a href="#ES6解决方案" class="headerlink" title="ES6解决方案"></a>ES6解决方案</h4><p>ES6在Number对象上新增了一个极小的常量——Number.EPSILON</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// &quot;0.00000000000000022204&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。</p>
<p>误差检查函数（出自《ES6标准入门》-阮一峰）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withinErrorMargin (left, right) &#123;</span><br><span class="line">    return Math.abs(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(0.1+0.2, 0.3)</span><br></pre></td></tr></table></figure>

<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="理解原型设计模式以及JavaScript中的原型规则"><a href="#理解原型设计模式以及JavaScript中的原型规则" class="headerlink" title="理解原型设计模式以及JavaScript中的原型规则"></a>理解原型设计模式以及JavaScript中的原型规则</h2><h2 id="instanceof的底层实现原理，手动实现一个instanceof"><a href="#instanceof的底层实现原理，手动实现一个instanceof" class="headerlink" title="instanceof的底层实现原理，手动实现一个instanceof"></a>instanceof的底层实现原理，手动实现一个instanceof</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function my_instanceof(obj, constructor) &#123;</span><br><span class="line">  let constuctProto = constructor.prototype</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (obj.__protp__ === null) &#123;</span><br><span class="line">      // 遍历完对象的原型链</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj.__proto__ === constuctProto) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    obj = obj.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.实现继承的几种方式以及他们的优缺点</p>
<blockquote>
<ol>
<li>prototype</li>
<li>extend</li>
<li>create</li>
</ol>
</blockquote>
<p>5.至少说出一种开源项目(如Node)中应用原型继承的案例</p>
<p>6.可以描述new一个对象的详细过程，手动实现一个new操作符</p>
<blockquote>
<p>首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说</p>
<p>然后吧argumentsy映射到新建的对象上（引用地址）</p>
<p>把原型链映射到新建的对象上</p>
</blockquote>
<p>7.理解es6 class构造以及继承的底层实现原理</p>
<blockquote>
<p>应该就是语法糖，对于prototype的优化把</p>
</blockquote>
<p>作用域和闭包<br>1.理解词法作用域和动态作用域</p>
<blockquote>
<p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
</blockquote>
<p>2.理解JavaScript的作用域和作用域链</p>
<blockquote>
<h3 id="全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象"><a href="#全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象" class="headerlink" title="全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象"></a>全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象</h3><h3 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h3><h2 id="作用域链-Scope-Chain-：所有的变量都会向上寻找表示"><a href="#作用域链-Scope-Chain-：所有的变量都会向上寻找表示" class="headerlink" title="作用域链(Scope Chain)：所有的变量都会向上寻找表示"></a>作用域链(Scope Chain)：所有的变量都会向上寻找表示</h2><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>
</blockquote>
<p>3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</p>
<blockquote>
<p>无法叙述</p>
</blockquote>
<p>4.this的原理以及几种不同使用场景的取值</p>
<blockquote>
<p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>
</blockquote>
<h4 id="情况一：全局-amp-调用普通函数"><a href="#情况一：全局-amp-调用普通函数" class="headerlink" title="情况一：全局 &amp; 调用普通函数"></a>情况一：全局 &amp; 调用普通函数</h4><p>在全局环境中，this 永远指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this === window);     //true</span><br></pre></td></tr></table></figure>

<p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this);     //Window</span><br><span class="line">    console.log(this.x);   //10</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h4 id="情况二：构造函数"><a href="#情况二：构造函数" class="headerlink" title="情况二：构造函数"></a>情况二：构造函数</h4><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">    console.log(this);    //Foo &#123;x:10&#125;</span><br><span class="line">&#125;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">console.log(foo.x);      //10</span><br></pre></td></tr></table></figure>

<p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p>
<p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">    console.log(this);    //Window</span><br><span class="line">&#125;</span><br><span class="line">var foo = Foo();</span><br><span class="line">console.log(foo.x);      //undefined</span><br></pre></td></tr></table></figure>

<h4 id="情况三：对象方法"><a href="#情况三：对象方法" class="headerlink" title="情况三：对象方法"></a>情况三：对象方法</h4><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        console.log(this);        //Object</span><br><span class="line">        console.log(this.x);      //10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p><strong>注意：若是在对象方法中定义函数，那么情况就不同了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        function f()&#123;</span><br><span class="line">            console.log(this);      //Window</span><br><span class="line">            console.log(this.x);    //undefined</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p>
<p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        function f()&#123;</span><br><span class="line">            console.log(self);      //&#123;x: 10&#125;</span><br><span class="line">            console.log(self.x);    //10</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>如果 foo 函数不作为对象方法被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function () &#123;</span><br><span class="line">        console.log(this);       //Window</span><br><span class="line">        console.log(this.x);     //undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var fn = obj.foo;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>
<h4 id="情况四：构造函数-prototype-属性"><a href="#情况四：构造函数-prototype-属性" class="headerlink" title="情况四：构造函数 prototype 属性"></a>情况四：构造函数 prototype 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.x = 10;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getX = function () &#123;</span><br><span class="line">    console.log(this);        //Foo &#123;x: 10, getX: function&#125;</span><br><span class="line">    console.log(this.x);      //10</span><br><span class="line">&#125;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.getX();</span><br></pre></td></tr></table></figure>

<p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p>
<h4 id="情况五：函数用-call、apply或者-bind-调用。"><a href="#情况五：函数用-call、apply或者-bind-调用。" class="headerlink" title="情况五：函数用 call、apply或者 bind 调用。"></a>情况五：函数用 call、apply或者 bind 调用。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this);     //&#123;x: 10&#125;</span><br><span class="line">    console.log(this.x);   //10</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj);</span><br><span class="line">foo.apply(obj);</span><br><span class="line">foo.bind(obj)();</span><br></pre></td></tr></table></figure>

<p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p>
<h4 id="情况六：DOM-event-this"><a href="#情况六：DOM-event-this" class="headerlink" title="情况六：DOM event this"></a>情况六：DOM event this</h4><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Listener()&#123;   </span><br><span class="line">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this</span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = function (event) &#123;</span><br><span class="line">    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">var listener = new Listener();</span><br><span class="line">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>

<p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">        console.log(this);         //Window</span><br><span class="line">        console.log(this.x);       //undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function foo(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125; </span><br><span class="line">foo(obj.fn);</span><br></pre></td></tr></table></figure>

<p>你也可以用通过 bind 切换上下文:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function  Listener()&#123;</span><br><span class="line">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      </span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = function (event) &#123;</span><br><span class="line">    console.log(this);    //Listener &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var listener = new Listener();</span><br><span class="line">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>

<p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p>
<h4 id="情况七：箭头函数中的-this"><a href="#情况七：箭头函数中的-this" class="headerlink" title="情况七：箭头函数中的 this"></a>情况七：箭头函数中的 this</h4><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                return () =&gt; &#123;</span><br><span class="line">                    console.log(this);      //Object &#123;x: 10&#125;</span><br><span class="line">                    console.log(this.x);    //10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn()()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p>
<p>如果使用箭头函数，以前的这种 hack 写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var self = this;</span><br></pre></td></tr></table></figure>

<p>就不再需要了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        var fn = () =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                return () =&gt; &#123;</span><br><span class="line">                    console.log(this);    // Object &#123;x: 10&#125;</span><br><span class="line">                    console.log(this.x);  //10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn.bind(&#123;x: 14&#125;)()()();</span><br><span class="line">        fn.call(&#123;x: 14&#125;)()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>
<h2 id="5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"><a href="#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用" class="headerlink" title="5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"></a>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</h2><p>JavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。<br>JavaScript闭包的本质是内存泄漏，指定内存不释放。 </p>
<p>应用：私有变量</p>
<p>##6.理解堆栈溢出和内存泄漏的原理，如何防止</p>
<p>溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包</p>
<h1 id="7-如何处理循环的异步操作"><a href="#7-如何处理循环的异步操作" class="headerlink" title="7.如何处理循环的异步操作"></a>7.如何处理循环的异步操作</h1><p>promise.all</p>
<p>#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</p>
<p>amd cmd umd    -》sea require npm</p>
<p>(function(a){</p>
<p>returm {</p>
<p>a:1</p>
<p>}<br>})(1)</p>
<p>#执行机制</p>
<p>##1.为何try里面放return，finally还会执行，理解其内部机制</p>
<p>类似promise？</p>
<p>##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</p>
<p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。</p>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop" target="_blank" rel="noopener">事件循环</a>期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>
<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##3.宏任务和微任务分别有哪些</p>
<p>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</p>
<p>分清楚 promise await settimeout的执行顺序</p>
<p>5.使用Promise实现串行</p>
<p>找一个第三方的缓存，把状态缓存住就行了</p>
<p>6.Node与浏览器EventLoop的差异</p>
<p>7.如何在保证页面运行流畅的情况下处理海量数据</p>
<p>不加载海量dom</p>
<p>语法和API<br>1.理解ECMAScript和JavaScript的关系</p>
<p>ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)</p>
<p>2.熟练运用es5、es6提供的语法规范，</p>
<p>3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</p>
<p>4.熟练应用map、reduce、filter 等高阶函数解决问题</p>
<p>5.setInterval需要注意的点，使用settimeout实现setInterval</p>
<p>6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</p>
<p>7.JavaScript异常处理的方式，统一的异常处理方案</p>
<p>HTML和CSS</p>
<p>HTML<br>1.从规范的角度理解HTML，从分类和语义的角度使用标签</p>
<p>早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化</p>
<p>2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式</p>
<p>3.元信息类标签(head、title、meta)的使用目的和配置方法</p>
<p>4.HTML5离线缓存原理</p>
<p>5.可以使用Canvas API、SVG等绘制高性能的动画</p>
<p>CSS<br>1.CSS盒模型，在不同浏览器的差异</p>
<p>2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则</p>
<p>3.CSS伪类和伪元素有哪些，它们的区别和实际应用</p>
<p>4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</p>
<p>5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点</p>
<p>6.BFC实现原理，可以解决的问题，如何创建BFC</p>
<p>7.可使用CSS函数复用代码，实现特殊效果</p>
<p>8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种</p>
<p>9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染</p>
<p>10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等</p>
<p>11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况</p>
<p>12.掌握一套完整的响应式布局方案</p>
<p>手写<br>1.手写图片瀑布流效果</p>
<p>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）</p>
<p>3.使用纯CSS实现曲线运动（贝塞尔曲线）</p>
<p>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p>
<p>计算机基础<br>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。<br>编译原理<br>1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</p>
<p>2.正则表达式的匹配原理和性能优化</p>
<p>3.如何将JavaScript代码解析成抽象语法树(AST)</p>
<p>4.base64的编码原理</p>
<p>5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换</p>
<p>网络协议<br>1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用</p>
<p>2.三次握手和四次挥手详细原理，为什么要使用这种机制</p>
<p>3.有哪些协议是可靠，TCP有哪些手段保证可靠交付</p>
<p>4.DNS的作用、DNS解析的详细过程，DNS优化原理</p>
<p>5.CDN的作用和原理</p>
<p>6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</p>
<p>7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题</p>
<p>8.HTTP1.1、HTTP2.0带来的改变</p>
<p>9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求</p>
<p>10.理解WebSocket协议的底层原理、与HTTP的区别</p>
<p>设计模式<br>1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</p>
<p>2.发布订阅模式和观察者模式的异同以及实际应用</p>
<p>3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</p>
<p>数据结构和算法<br>据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！</p>
<p>JavaScript编码能力<br>1.多种方式实现数组去重、扁平化、对比优缺点</p>
<p>2.多种方式实现深拷贝、对比优缺点</p>
<p>3.手写函数柯里化工具函数、并理解其应用场景和优势</p>
<p>4.手写防抖和节流工具函数、并理解其内部原理和应用场景</p>
<p>5.实现一个sleep函数</p>
<p>手动实现前端轮子<br>1.手动实现call、apply、bind</p>
<p>2.手动实现符合Promise/A+规范的Promise、手动实现async await</p>
<p>3.手写一个EventEmitter实现事件发布、订阅</p>
<p>4.可以说出两种实现双向绑定的方案、可以手动实现</p>
<p>5.手写JSON.stringify、JSON.parse</p>
<p>6.手写一个模版引擎，并能解释其中原理</p>
<p>7.手写懒加载、下拉刷新、上拉加载、预加载等效果</p>
<p>数据结构<br>1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</p>
<p>2.理解数组、字符串的存储原理，并熟练应用他们解决问题</p>
<p>3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</p>
<p>4.了解图、堆的基本结构和使用场景</p>
<p>算法<br>1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</p>
<p>2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度</p>
<p>3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</p>
<p>4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</p>
<p>5.前端处理海量数据的算法方案</p>
<p>运行环境<br>我们需要理清语言和环境的关系：<br>ECMAScript描述了JavaScript语言的语法和基本对象规范</p>
<p>浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口</p>
<p>Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API</p>
<p>浏览器API<br>1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性</p>
<p>2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性</p>
<p>3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)</p>
<p>4.浏览器海量数据存储、操作性能优化</p>
<p>5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理</p>
<p>6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库</p>
<p>7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型</p>
<p>8.浏览器提供的几种存储机制、优缺点、开发中正确的选择</p>
<p>9.浏览器跨标签通信</p>
<p>浏览器原理<br>1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分</p>
<p>2.请求数据到请求结束与服务器进行了几次交互</p>
<p>3.可详细描述浏览器从输入URL到页面展现的详细过程</p>
<p>4.浏览器解析HTML代码的原理，以及构建DOM树的流程</p>
<p>5.浏览器如何解析CSS规则，并将其应用到DOM树上</p>
<p>6.浏览器如何将解析好的带有样式的DOM树进行绘制</p>
<p>7.浏览器的运行机制，如何配置资源异步同步加载</p>
<p>8.浏览器回流与重绘的底层原理，引发原因，如何有效避免</p>
<p>9.浏览器的垃圾回收机制，如何避免内存泄漏</p>
<p>10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案</p>
<p>Node<br>1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等</p>
<p>2.掌握一种Node开发框架，如Express，Express和Koa的区别</p>
<p>3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理</p>
<p>4.Node的底层运行原理、和浏览器的异同</p>
<p>5.Node事件驱动、非阻塞机制的实现原理</p>
<p>框架和类库<br>轮子层出不穷，从原理上理解才是正道<br>TypeScript<br>1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现</p>
<p>2.理解使用TypeScript的好处，掌握TypeScript基础语法</p>
<p>3.TypeScript的规则检测原理</p>
<p>4.可以在React、Vue等框架中使用TypeScript进行开发</p>
<p>React<br>1.React和vue 选型和优缺点、核心架构的区别</p>
<p>2.React中setState的执行机制，如何有效的管理状态</p>
<p>3.React的事件底层实现机制</p>
<p>4.React的虚拟DOM和Diff算法的内部实现</p>
<p>5.React的Fiber工作原理，解决了什么问题</p>
<p>6.React Router和Vue Router的底层实现原理、动态加载实现原理</p>
<p>7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题</p>
<p>8.基于React的特性和原理，可以手动实现一个简单的React</p>
<p>Vue<br>1.熟练使用Vue的API、生命周期、钩子函数</p>
<p>2.MVVM框架设计理念</p>
<p>3.Vue双向绑定实现原理、Diff算法的内部实现</p>
<p>4.Vue的事件机制</p>
<p>5.从template转换成真实DOM的实现机制</p>
<p>多端开发<br>1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案</p>
<p>2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用</p>
<p>3.移动端页面适配解决方案、不同机型适配方案</p>
<p>4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配</p>
<p>5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理</p>
<p>6.掌握一种小程序开发框架或原生小程序开发</p>
<p>7.理解多端框架的内部实现原理，至少了解一个多端框架的使用</p>
<p>数据流管理<br>1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同</p>
<p>2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理</p>
<p>3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势</p>
<p>4.熟练使用Vuex管理数据流，并理解其实现原理</p>
<p>5.以上数据流方案的异同和优缺点，不情况下的技术选型</p>
<p>实用库<br>1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现</p>
<p>2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表</p>
<p>3.掌握一种GIS开发框架，如百度地图API</p>
<p>4.掌握一种可视化开发框架，如Three.js、D3</p>
<p>5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理</p>
<p>开发和调试<br>1.熟练使用各浏览器提供的调试工具</p>
<p>2.熟练使用一种代理工具实现请求代理、抓包，如charls</p>
<p>3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案</p>
<p>4.了解Vue、React等框架调试工具的使用</p>
<p>前端工程<br>前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度<br>项目构建<br>1.理解npm、yarn依赖包管理的原理，两者的区别</p>
<p>2.可以使用npm运行自定义脚本</p>
<p>3.理解Babel、ESLint、webpack等工具在项目中承担的作用</p>
<p>4.ESLint规则检测原理，常用的ESLint配置</p>
<p>5.Babel的核心原理，可以自己编写一个Babel插件</p>
<p>6.可以配置一种前端代码兼容方案，如Polyfill</p>
<p>7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用</p>
<p>8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins</p>
<p>nginx<br>1.正向代理与反向代理的特点和实例</p>
<p>2.可手动搭建一个简单的nginx服务器、</p>
<p>3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法</p>
<p>4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理</p>
<p>开发提速<br>1.熟练掌握一种接口管理、接口mock工具的使用，如yapi</p>
<p>2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题</p>
<p>3.理解TDD与BDD模式，至少会使用一种前端单元测试框架</p>
<p>版本控制<br>1.理解Git的核心原理、工作流程、和SVN的区别</p>
<p>2.熟练使用常规的Git命令、git rebase、git stash等进阶命令</p>
<p>3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题</p>
<p>持续集成<br>1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins</p>
<p>2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）</p>
<p>项目和业务</p>
<p>后端技能<br>1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言</p>
<p>2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库</p>
<p>性能优化<br>1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案</p>
<p>2.了解常见的Web、App性能优化方案</p>
<p>3.SEO排名规则、SEO优化方案、前后端分离的SEO</p>
<p>4.SSR实现方案、优缺点、及其性能优化</p>
<p>5.Webpack的性能优化方案</p>
<p>6.Canvas性能优化方案</p>
<p>7.React、Vue等框架使用性能优化方案</p>
<p>前端安全<br>1.XSS攻击的原理、分类、具体案例，前端如何防御</p>
<p>2.CSRF攻击的原理、具体案例，前端如何防御</p>
<p>3.HTTP劫持、页面劫持的原理、防御措施</p>
<p>业务相关<br>1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题</p>
<p>2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题</p>
<p>3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性</p>
<p>学习提升</p>
<p>vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：</p>
<p>这十几年我一共做了三件事：</p>
<p>1、不以赚钱为目的选择学习的内容；</p>
<p>2、以自己是否能造出轮子来衡量学习的效果；</p>
<p>3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。</p>
<p>上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。</p>
<p>关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多</p>
<p>1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏</p>
<p>2.定期的将知识进行总结，不断完善自己的知识体系</p>
<p>3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用</p>
<p>4.坚持输出自己的代码，不要盲目的扎进公司业</p>
<p>技术之外</p>
<p>这部分可能比上面九条加起来重要！</p>
<p>1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等</p>
<p>2.了解互联网行业术语：B2B、B2C、C2C、O2O等</p>
<p>3.掌握互联网行业沟通、问答、学习的</p>
<p>4.有一定的”PPT”能力</p>
<p>5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识</p>
<p>6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系<br>.如何理解 JS 中的this关键字？</p>
<ol>
<li>由于 this 关键字很混乱，如何解决这个问题<br>3.什么是闭包<br>4.解释一下变量的提升</li>
<li>JavaScript如何处理同步和异步情况</li>
<li>如何理解事件委托</li>
<li>如何理解高阶函数。</li>
<li>如何区分声明函数和表达式函数</li>
<li>解释一下严格模式(strict mode)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/每日一问/" data-id="ckg39g70y0005l8vpl4jt6780" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/设计模式/" class="article-date">
  <time datetime="2020-10-10T05:21:37.320Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><p>1.单一职责原则:只做一件事情<br>2.里氏替换原则:同岗位人之间可以互相调换<br>3.依赖倒转原则:应用层依赖底层，但是底层不依赖应用层<br>4.接口隔离原则:模块只声明自己需要的接口<br>5.迪米特法则:在你眼里，我应该是黑盒。<br>6.开闭原则:你只能看，不能改</p>
<ol>
<li>开闭原则： 对扩展开放，对修改关闭</li>
<li>里氏转换原则： 子类继承父类，单独完全可以运行</li>
<li>依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型</li>
<li>接口隔离原则： 每一个接口应该是一种角色</li>
<li>合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分</li>
<li>迪米特原则： 一个对象应对其他对象有尽可能少的了解</li>
</ol>
<blockquote>
<p>我会在下面设计的模式中，声明使用到对应的原则</p>
</blockquote>
<h1 id="为什么要尽量使用白话"><a href="#为什么要尽量使用白话" class="headerlink" title="为什么要尽量使用白话"></a>为什么要尽量使用白话</h1><blockquote>
<p>纯术语的文章太多，不利于归纳成记忆点，尤其是实际应用中。所以我尝试着能否使用白话或者极度精简的文字去分解这些复杂侃长的语句。</p>
</blockquote>
<h1 id="为什么要使用设计模式"><a href="#为什么要使用设计模式" class="headerlink" title="为什么要使用设计模式"></a>为什么要使用设计模式</h1><blockquote>
<p>开发人员A碰到了一个问题，就找开发B,开发B说用”xxxx设计模式就行了”，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”<br>但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。</p>
        
          <p class="article-more-link">
            <a href="/2020/10/10/设计模式/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/设计模式/" data-id="ckg39g70y0006l8vpk6vv50cf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-form表单规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/form表单规范/" class="article-date">
  <time datetime="2020-10-10T05:21:37.318Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="C:%5CUsers%5Clinbinbin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1562046444629.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/form表单规范/" data-id="ckg39g70l0000l8vp51seecxk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/hello-world/" class="article-date">
  <time datetime="2020-10-10T05:21:37.318Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/hello-world/" data-id="ckg39g70t0001l8vpcpwdxk99" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-less" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/less/" class="article-date">
  <time datetime="2020-10-10T05:21:37.318Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#基础语法糖</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/less/" data-id="ckg39g70u0002l8vpaaujdts1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-小工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/小工具/" class="article-date">
  <time datetime="2020-10-10T05:21:37.318Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="喝水闹钟"><a href="#喝水闹钟" class="headerlink" title="[喝水闹钟"></a>[喝水闹钟</h1><h1 id="待办事项（与github-api打通）"><a href="#待办事项（与github-api打通）" class="headerlink" title="待办事项（与github api打通）"></a>待办事项（与github api打通）</h1><h1 id="vue底层重构"><a href="#vue底层重构" class="headerlink" title="vue底层重构"></a>vue底层重构</h1><h1 id="支持cdn地址的资源"><a href="#支持cdn地址的资源" class="headerlink" title="支持cdn地址的资源"></a>支持cdn地址的资源</h1><h1 id="支持2dlive-unity-静态图片的方式"><a href="#支持2dlive-unity-静态图片的方式" class="headerlink" title="支持2dlive+unity+静态图片的方式"></a>支持2dlive+unity+静态图片的方式</h1><p>极简模式</p>
<p>pck快速解压工具开发（底层要变化）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/小工具/" data-id="ckg39g70v0003l8vpgv51ejor" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/10/Html/" class="article-date">
  <time datetime="2020-10-10T05:21:37.317Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="源"><a href="#源" class="headerlink" title="源"></a>源</h1><p>以下内容摘自wiki百科</p>
<blockquote>
<p>1980年，物理学家<a href="https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李" target="_blank" rel="noopener">蒂姆·伯纳斯-李</a>在<a href="https://zh.wikipedia.org/wiki/歐洲核子研究組織" target="_blank" rel="noopener">欧洲核子研究中心</a>（CERN）在承包工程期间，为使CERN的研究人员使用并共享文档，他提出并创建原型系统<a href="https://zh.wikipedia.org/wiki/ENQUIRE" target="_blank" rel="noopener">ENQUIRE</a>。1989年，伯纳斯-李在一份备忘录中提出一个基于<a href="https://zh.wikipedia.org/wiki/互联网" target="_blank" rel="noopener">互联网</a>的<a href="https://zh.wikipedia.org/wiki/超文本" target="_blank" rel="noopener">超文本</a>系统<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-5" target="_blank" rel="noopener">[5]</a>。他规定HTML并在1990年底写出浏览器和服务器软件。同年，伯纳斯-李与CERN的数据系统工程师<a href="https://zh.wikipedia.org/wiki/罗伯特·卡里奥" target="_blank" rel="noopener">罗伯特·卡里奥</a>联合为项目申请资助，但未被CERN正式批准。在他的个人笔记中<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-6" target="_blank" rel="noopener">[6]</a>伯纳斯-李列举“一些使用超文本的领域”，并把百科全书列为首位<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-7" target="_blank" rel="noopener">[7]</a>。<br>HTML的首个公开描述出现于一个名为“HTML标签”的文件中，由蒂姆·伯纳斯-李于1991年底提及<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-tagshtml-8" target="_blank" rel="noopener">[8]</a><a href="https://zh.wikipedia.org/wiki/HTML#cite_note-9" target="_blank" rel="noopener">[9]</a>。它描述18个元素，包括HTML初始的、相对简单的设计。除了超链接标签外，其他设计都深受CERN内部一个以<a href="https://zh.wikipedia.org/wiki/SGML" target="_blank" rel="noopener">标准通用标记语言</a>（SGML）为基础的文件格式SGMLguid的影响。这些元素在HTML 4中仍有11个存在<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-10" target="_blank" rel="noopener">[10]</a>。<br>伯纳斯-李认为HTML是SGML的一个应用程序。1993年中期<a href="https://zh.wikipedia.org/wiki/互联网工程任务组" target="_blank" rel="noopener">互联网工程任务组</a>（IETF）发布首个HTML规范的提案：<a href="http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt" target="_blank" rel="noopener">“超文本标记语言（HTML）”互联网草案</a>，由伯纳斯-李与<a href="https://zh.wikipedia.org/w/index.php?title=丹·康纳利&action=edit&redlink=1" target="_blank" rel="noopener">丹·康纳利</a>撰写。其中包括一个SGML<a href="https://zh.wikipedia.org/wiki/文件类型描述" target="_blank" rel="noopener">文档类型定义</a>来定义语法<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-11" target="_blank" rel="noopener">[11]</a>。草案于6个月后过期，不过值得注意的是其对<a href="https://zh.wikipedia.org/wiki/NCSA_Mosaic" target="_blank" rel="noopener">NCSA Mosaic</a>浏览器自定义标签从而将在线图像嵌入的行为的认可，这反映IETF把标准立足于成功原型的理念<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-raymond-12" target="_blank" rel="noopener">[12]</a>。同样，<a href="https://zh.wikipedia.org/w/index.php?title=戴夫·拉格特&action=edit&redlink=1" target="_blank" rel="noopener">戴夫·拉格特</a>在1993年末提出的与之竞争的互联网草案“HTML+（超文本标记格式）”建议规范已经实现的功能，如表格与填写表单<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-html+-13" target="_blank" rel="noopener">[13]</a>。</p>
<p>在HTML和HTML+的草案于1994年初到期后，IETF创建一个HTML工作组，并在1995年完成”HTML 2.0”，这是第一个旨在成为对其后续实现标准的依据的HTML规范<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-14" target="_blank" rel="noopener">[14]</a>。</p>
<p>在IETF的主持下，HTML标准的进一步发展因竞争利益而遭受停滞。自1996年起，HTML规范一直由<a href="https://zh.wikipedia.org/wiki/万维网联盟" target="_blank" rel="noopener">万维网联盟</a>（W3C）维护，并由商业软件厂商出资<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-raggett-15" target="_blank" rel="noopener">[15]</a>。不过在2000年，HTML也成为国际标准（<a href="https://zh.wikipedia.org/wiki/國際標準化組織" target="_blank" rel="noopener">ISO</a>/ <a href="https://zh.wikipedia.org/wiki/IEC" target="_blank" rel="noopener">IEC</a>15445：2000）。HTML 4.01于1999年末发布，进一步的勘误版本于2001年发布。2004年，<a href="https://zh.wikipedia.org/wiki/網頁超文本技術工作小組" target="_blank" rel="noopener">网页超文本应用技术工作小组</a>（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-16" target="_blank" rel="noopener">[16]</a>。<a href="https://en.wikipedia.org/wiki/HTML#cite_note-14" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTML#cite_note-14</a>)</p>
</blockquote>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><blockquote>
<p>1995年11月24日<br>HTML 2.0作为IETF RFC 1866发布。追加RFC的附加功能：<br>1995年11月25日：RFC 1867（基于表单的文件上传）<br>1996年5月：RFC 1942（表格）<br>1996年8月：RFC 1980（客户端图像映射）<br>1997年1月：RFC 2070（国际化）<br>1997年1月14日<br>HTML 3.2[17]作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组[18]。<br>最初代号为“威尔伯”（Wilbur）[19]，HTML 3.2完全去除数学公式，协调各种专有扩展，并采用网景设计的大多数视觉标记标签。由于两家公司达成了协议，网景的闪烁元素和微软的滚动元素被移除[15]。HTML对数学公式的支持最后成为另外一种被称为MathML的标准。<br>1997年12月18日<br>HTML 4.0[20]作为W3C推荐标准发布。它提供三种变化：<br>严格，过时的元素被禁止。<br>过渡，过时的元素被允许。<br>框架集，大多只与框架相关的元素被允许。<br>最初代号“美洲狮”（Cougar）[19]， HTML 4.0采用许多特定浏览器的元素类型和属性，并试图淘汰网景的视觉标记功能，将其标记为不赞成使用。HTML 4是遵循ISO 8879 - SGML的SGML应用程序[21]。<br>1998年4月24日<br>HTML 4.0[22]进行微调，不增加版本号。<br>1999年12月24日<br>HTML 4.01[23]作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。<br>2000年5月<br>ISO/IEC 15445:2000[24][25]（”ISO HTML”，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于ISO/IEC JTC 1/SC 34域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）[24]。<br>2014年10月28日<br>HTML 5[26]作为W3C推荐标准发布[27]。<br>草案时间线</p>
</blockquote>
<blockquote>
<p>HTML5的Logo<br>1991年10月<br>HTML标签[8]，一个非正式CERN文件首次公开18个HTML标签。<br>1992年6月<br>HTML DTD的首个非正式草案[28]， 后续有七个修订版[29][30][31]（7月15日，8月6日，8月18日，11月17日，11月19日，11月20日，11月22日）。<br>1992年11月<br>HTML DTD 1.1（首个版本号，基于RCS修订版，版本号从1.1开始而非1.0），非正式草案。[31]<br>1993年6月<br>超文本标记语言[32]由IETF IIIR工作小组作为互联网草案（一个粗略的建议标准）。在被第二版[33]取代一个月后，IETF又发布6个草案[34]，最终在RFC1866中发布HTML 2.0。<br>1993年11月<br>HTML+由IETF作为互联网草案发布，是超文本标记语言草案的一个竞争性提案。它于1994年5月到期。<br>1995年4月 （1995年3月编写）<br>HTML 3.0[35]被提议作为IETF的标准，但直到提案在五个月过期后（1995年9月28日）[36]仍没有进一步的行动。它包含许多拉格特HTML+提案的功能，如对表格的支持、围绕数据的文本流和复杂的数学公式的显示[36]。W3C开始开发自己的Arena浏览器作为HTML 3和层叠样式表的试验台[37][38][39]，但HTML 3.0并没有获得成功。浏览器厂商，包括微软和网景，选择实现HTML3草案功能的不同子集并引入它们自己的插件（见浏览器大战）[15]。<br>2008年1月<br>HTML5由W3C作为工作草案（链接）发布[40]。虽然HTML5的语法非常类似于SGML，但它已经放弃任何成为SGML应用程序的尝试，除了一种替代的基于XML的HTML5序列，它已明确定义自己的“HTML”序列[41]。<br>2011年 HTML5 – 最终征求<br>2011年5月，工作小组将HTML5推进至“最终征求”（Last Call）阶段，邀请W3C社区内外人士以确认本规范的技术可靠性。W3C开发一套综合性测试包来实现完整规范的广泛交互操作性，完整规范的目标日期为2014年[42]。2011年1月，WHATWG将其“HTML5”活动标准重命名为“HTML”。W3C仍然继续其发布HTML5的项目[43]。<br>2012年 HTML5 – 候选推荐<br>2012年7月，WHATWG和W3C的工作产生一定程度的分离。W3C继续HTML5规范工作，重点放在单一明确的标准上，这被WHATWG称为“快照”。WHATWG组织则将HTML5作为一个“活动标准”（Living Standard）。活动标准的概念是从未完成但永远保持更新与改进，可以蒂姆加新特性，但功能点不会被删除。[44]<br>2012年12月，W3C指定HTML5作为候选推荐[45]阶段。 该阶段的标准为“两个100％完成，完全实现交互操作”。<br>2014年 HTML5 – 提案推荐与推荐<br>2014年9月，HTML5进入提案推荐阶段。[46]<br>2014年10月28日，HTML5作为稳定W3C推荐标准发布[47]，这意味着HTML5的标准化已经完成[48]。<br>XHTML版本<br>主条目：XHTML<br>XHTML是使用XML 1.0改写自HTML 4.01的独立语言。它不再被作为单独标准开发。</p>
</blockquote>
<blockquote>
<p>XHTML 1.0[49]， 2000年1月26日作为W3C推荐标准发布。修订版于2002年8月1日发布，它提供与HTML 4.0和4.01相同的三个变化，这些变化被重新在XML中制定。<br>XHTML 1.1[50]，基于XHTML 1.0 严格版，2001年5月31日 作为W3C推荐标准发布。修订版可使用模块化XHTML的模块，2001年4月10日作为W3C推荐标准发布。<br>XHTML 2.0为工作草案，但为支持HTML5与XHTML5的工作，此草案被放弃[51][52][53]。 XHTML 2.0与XHTML 1.x不兼容，因此更确切的说这是一个XHTML风格的新语言而不是XHTML 1.x的更新。<br>在HTML5草案中规定一个XHTML语法，称为“XHTML5.1”[54]。</p>
</blockquote>
<h1 id="定义（what）"><a href="#定义（what）" class="headerlink" title="定义（what）"></a>定义（what）</h1><blockquote>
<p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建<a href="https://zh.wikipedia.org/wiki/网页" target="_blank" rel="noopener">网页</a>的标准<a href="https://zh.wikipedia.org/wiki/标记语言" target="_blank" rel="noopener">标记语言</a>。HTML是一种基础技术，常与<a href="https://zh.wikipedia.org/wiki/CSS" target="_blank" rel="noopener">CSS</a>、<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-3" target="_blank" rel="noopener">[3]</a>。<a href="https://zh.wikipedia.org/wiki/网页浏览器" target="_blank" rel="noopener">网页浏览器</a>可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非<a href="https://zh.wikipedia.org/wiki/编程语言" target="_blank" rel="noopener">编程语言</a>。</p>
<p><a href="https://zh.wikipedia.org/wiki/HTML元素" target="_blank" rel="noopener">HTML元素</a>是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和<a href="https://zh.wikipedia.org/wiki/语义" target="_blank" rel="noopener">语义</a>。HTML的语言形式为<a href="https://zh.wikipedia.org/wiki/括号" target="_blank" rel="noopener">尖括号</a>包围的HTML元素（如<code>&lt;html&gt;</code>），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。</p>
<p>HTML可以嵌入如<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>的<a href="https://zh.wikipedia.org/wiki/脚本语言" target="_blank" rel="noopener">脚本语言</a>，它们会影响HTML网页的行为。网页浏览器也可以引用<a href="https://zh.wikipedia.org/wiki/层叠样式表" target="_blank" rel="noopener">层叠样式表</a>（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织<a href="https://zh.wikipedia.org/wiki/万维网联盟" target="_blank" rel="noopener">万维网联盟</a>（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素<a href="https://zh.wikipedia.org/wiki/HTML#cite_note-deprecated-4" target="_blank" rel="noopener">[4]</a>。</p>
</blockquote>
<h1 id="标记（what）"><a href="#标记（what）" class="headerlink" title="标记（what）"></a>标记（what）</h1><p><img src="https://tycn.gitbooks.io/css/assets/html.png" alt="img"></p>
<h1 id="底层核心，dom的渲染过程（HOW）"><a href="#底层核心，dom的渲染过程（HOW）" class="headerlink" title="底层核心，dom的渲染过程（HOW）"></a>底层核心，dom的渲染过程（HOW）</h1><ol>
<li>解析HTML，构建DOM树（这里遇到外链，此时会发起请求）</li>
<li>解析CSS，生成CSS规则树</li>
<li>合并DOM树和CSS规则，生成render树</li>
<li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制render树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上</li>
</ol>
<ul>
<li>reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；</li>
<li>repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</li>
</ul>
<h1 id="语义HTML，语义-标签的现状（WHY）"><a href="#语义HTML，语义-标签的现状（WHY）" class="headerlink" title="语义HTML，语义/标签的现状（WHY）"></a>语义HTML，语义/标签的现状（WHY）</h1><blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/10/Html/" data-id="ckg39g70w0004l8vpzedfbwl4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/10/每日一问/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/设计模式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/form表单规范/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/10/less/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>